//路径交叉问题
//给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。
//编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。

#include <vector>
using namespace std;

//普遍情况i需要考察到 i -5, 先行处理前0-4
//不交叉情况下，只有向外旋和内旋两种情况
bool isSelfCrossing(vector<int>& x) 
{
    //1-3不可能相交,处理0 - 2
    if(x.size() < 4)
    {
        return false;
    };
    
    if((x.size() > 3 && x[0] >= x[2] && x[3] >= x[1])  //处理3
      || (x.size() > 4 && ((x[3] <= x[1] && x[4] >= x[2]) || (x[3] == x[1] && x[0] + x[4] >= x[2]))))  //处理4
    {
        return true;
    }

    //普遍处理5及其以上
    for (int i = 5; i < x.size(); i++) 
    {
        // if ((x[i - 1] <= x[i - 3] && (x[i] >= x[i - 2]))
        //     || 
        //     ((x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 4] + x[i] >= x[i - 2])))
             
        // {
        //     return true;
        // }

        if (x[i - 1] <= x[i - 3] && ((x[i] >= x[i - 2]) || (x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 4] + x[i] >= x[i - 2])
                                                        || (x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] < x[i - 3]  && x[i] >= x[i - 2]))) 
        {
				return true;
		}
    };
    return false;
}